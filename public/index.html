<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Call with Screen Sharing (Multi-User)</title>
    <style>
        video {
            width: 45%;
            margin: 10px;
        }
        #localVideo {
            border: 2px solid black;
        }
    </style>
</head>
<body>
    <h1>Video Call with Screen Sharing (Multi-User)</h1>
    <div>
        <video id="localVideo" autoplay muted></video>
    </div>
    <div id="remoteVideosContainer"></div>
    <div>
        <button id="startCall">Start Call</button>
        <button id="shareScreen">Share Screen</button>
    </div>

    <script src="https://cdn.socket.io/4.1.3/socket.io.min.js"></script>
    <script>
        const socket = io();
        const roomId = 'test-room'; // Room ID for the call

        const localVideo = document.getElementById('localVideo');
        const remoteVideosContainer = document.getElementById('remoteVideosContainer');
        const startCallButton = document.getElementById('startCall');
        const shareScreenButton = document.getElementById('shareScreen');

        let localStream;
        let screenStream;
        const peerConnections = {}; // Map of peer connections per user
        const remoteVideos = {}; // Map of video elements per user

        const servers = {
            iceServers: [
                {
                    urls: 'stun:stun.l.google.com:19302'
                }
            ]
        };

        // Join the room when the page loads
        socket.emit('join-room', roomId);

        // Handle new user joining
        socket.on('new-user', (userId) => {
            console.log(`New user joined: ${userId}`);
            setupPeerConnection(userId);
        });

        // Remove user when they leave
        socket.on('user-left', (userId) => {
            console.log(`User left: ${userId}`);
            if (peerConnections[userId]) {
                peerConnections[userId].close();
                delete peerConnections[userId];
            }
            if (remoteVideos[userId]) {
                remoteVideosContainer.removeChild(remoteVideos[userId]);
                delete remoteVideos[userId];
            }
        });

        // Start the video call
        startCallButton.addEventListener('click', async () => {
            if (!localStream) {
                localStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
            }
            localVideo.srcObject = localStream;

            // Notify others you're ready
            socket.emit('ready', roomId);
        });

        // Handle incoming messages (offer/answer/ICE candidates)
        socket.on('message', async (data) => {
            const { from, offer, answer, candidate } = data;

            if (offer) {
                console.log('Received offer from', from);
                const peerConnection = setupPeerConnection(from);
                await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));

                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                socket.emit('message', { roomId, to: from, answer });
            } else if (answer) {
                console.log('Received answer from', from);
                if (peerConnections[from]) {
                    await peerConnections[from].setRemoteDescription(new RTCSessionDescription(answer));
                }
            } else if (candidate) {
                console.log('Received ICE candidate from', from);
                if (peerConnections[from]) {
                    await peerConnections[from].addIceCandidate(new RTCIceCandidate(candidate));
                }
            }
        });

        // Screen sharing functionality
       

        function setupPeerConnection(userId) {
            const peerConnection = new RTCPeerConnection(servers);

            // Add local stream tracks
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });
            }

            // Handle remote track
            peerConnection.ontrack = (event) => {
                console.log(`Received track from user: ${userId}`);
                if (!remoteVideos[userId]) {
                    remoteVideos[userId] = createRemoteVideoElement(userId);
                }
                remoteVideos[userId].srcObject = event.streams[0];
            };

            // Handle ICE candidate
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    socket.emit('message', {
                        roomId,
                        to: userId,
                        candidate: event.candidate
                    });
                }
            };

            peerConnections[userId] = peerConnection;
            return peerConnection;
        }
        // Create a new video element for a remote user
        function createRemoteVideoElement(userId) {
            const video = document.createElement('video');
            video.id = `remoteVideo-${userId}`;
            video.autoplay = true;
            video.playsInline = true;
            video.style.border = '2px solid green';
            video.style.width = '45%';
            remoteVideosContainer.appendChild(video);
            return video;
        }
    </script>
</body>
</html>
